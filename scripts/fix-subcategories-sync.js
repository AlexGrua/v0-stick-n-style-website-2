const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');

function loadEnv() {
  const envPath = path.join(process.cwd(), '.env.local');
  if (fs.existsSync(envPath)) {
    const envContent = fs.readFileSync(envPath, 'utf8');
    envContent.split('\n').forEach(line => {
      const [key, value] = line.split('=');
      if (key && value) {
        process.env[key.trim()] = value.trim();
      }
    });
  }
}
loadEnv();

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

async function fixSubcategoriesSync() {
  console.log('üîß –ò—Å–ø—Ä–∞–≤–ª—è—é —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é subcategories...\n');

  try {
    // 1. –°–æ–∑–¥–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ subs
    console.log('üìù –°–æ–∑–¥–∞—é —Ñ—É–Ω–∫—Ü–∏—é –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ subs...');
    const createFunctionSQL = `
      CREATE OR REPLACE FUNCTION public.rebuild_category_subs(p_category_id int)
      RETURNS void LANGUAGE plpgsql AS $$
      BEGIN
        UPDATE public.categories c
        SET subs = COALESCE((
          SELECT jsonb_agg(jsonb_build_object('id', s.id, 'name', s.name) ORDER BY s.id)
          FROM public.subcategories s
          WHERE s.category_id = p_category_id
        ), '[]'::jsonb)
        WHERE c.id = p_category_id;
      END $$;
    `;

    try {
      const response = await fetch('http://localhost:3000/api/migrations/execute-sql', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sql: createFunctionSQL }),
      });
      const result = await response.json();
      if (result.success) {
        console.log('‚úÖ –§—É–Ω–∫—Ü–∏—è rebuild_category_subs —Å–æ–∑–¥–∞–Ω–∞');
      } else {
        console.log('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏:', result.error);
      }
    } catch (error) {
      console.log('‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è SQL:', error.message);
    }

    // 2. –°–æ–∑–¥–∞–µ–º —Ç—Ä–∏–≥–≥–µ—Ä—ã
    console.log('\nüîó –°–æ–∑–¥–∞—é —Ç—Ä–∏–≥–≥–µ—Ä—ã...');
    const createTriggersSQL = `
      -- –¢—Ä–∏–≥–≥–µ—Ä –¥–ª—è INSERT
      DROP TRIGGER IF EXISTS trg_subcategories_ins ON public.subcategories;
      CREATE TRIGGER trg_subcategories_ins
      AFTER INSERT ON public.subcategories
      FOR EACH ROW EXECUTE FUNCTION public.rebuild_category_subs(NEW.category_id);

      -- –¢—Ä–∏–≥–≥–µ—Ä –¥–ª—è UPDATE
      DROP TRIGGER IF EXISTS trg_subcategories_upd ON public.subcategories;
      CREATE TRIGGER trg_subcategories_upd
      AFTER UPDATE ON public.subcategories
      FOR EACH ROW EXECUTE FUNCTION public.rebuild_category_subs(COALESCE(NEW.category_id, OLD.category_id));

      -- –¢—Ä–∏–≥–≥–µ—Ä –¥–ª—è DELETE
      DROP TRIGGER IF EXISTS trg_subcategories_del ON public.subcategories;
      CREATE TRIGGER trg_subcategories_del
      AFTER DELETE ON public.subcategories
      FOR EACH ROW EXECUTE FUNCTION public.rebuild_category_subs(OLD.category_id);
    `;

    try {
      const response = await fetch('http://localhost:3000/api/migrations/execute-sql', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sql: createTriggersSQL }),
      });
      const result = await response.json();
      if (result.success) {
        console.log('‚úÖ –¢—Ä–∏–≥–≥–µ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã');
      } else {
        console.log('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤:', result.error);
      }
    } catch (error) {
      console.log('‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è SQL:', error.message);
    }

    // 3. –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ
    console.log('\nüîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É—é —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ...');
    const syncExistingSQL = `
      DO $$
      DECLARE r RECORD;
      BEGIN
        FOR r IN SELECT id FROM public.categories LOOP
          PERFORM public.rebuild_category_subs(r.id);
        END LOOP;
      END $$;
    `;

    try {
      const response = await fetch('http://localhost:3000/api/migrations/execute-sql', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sql: syncExistingSQL }),
      });
      const result = await response.json();
      if (result.success) {
        console.log('‚úÖ –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã');
      } else {
        console.log('‚ùå –û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏:', result.error);
      }
    } catch (error) {
      console.log('‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è SQL:', error.message);
    }

    // 4. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º PostgREST
    console.log('\nüîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—é PostgREST...');
    const reloadSQL = `
      NOTIFY pgrst, 'reload schema';
      SELECT pg_notify('pgrst', 'reload schema');
    `;

    try {
      const response = await fetch('http://localhost:3000/api/migrations/execute-sql', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sql: reloadSQL }),
      });
      const result = await response.json();
      if (result.success) {
        console.log('‚úÖ PostgREST –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω');
      } else {
        console.log('‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ PostgREST:', result.error);
      }
    } catch (error) {
      console.log('‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è SQL:', error.message);
    }

    // 5. –ñ–¥–µ–º –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º
    console.log('\n‚è≥ –ñ–¥—É 5 —Å–µ–∫—É–Ω–¥...');
    await new Promise(resolve => setTimeout(resolve, 5000));

    // 6. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç...');
    const { data: categories, error: catError } = await supabase
      .from('categories')
      .select('id, name, subs')
      .limit(5);
    
    if (catError) {
      console.log(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π: ${catError.message}`);
    } else {
      console.log(`‚úÖ –ü–æ–ª—É—á–µ–Ω–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: ${categories?.length || 0}`);
      categories?.forEach(cat => {
        console.log(`üìã ${cat.name} (ID: ${cat.id}): ${cat.subs?.length || 0} subcategories`);
      });
    }

    // 7. –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    console.log('\nüß™ –¢–µ—Å—Ç–∏—Ä—É—é —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏...');
    if (categories && categories.length > 0) {
      const categoryId = categories[0].id;
      
      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤—É—é –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é
      const { data: insertResult, error: insertError } = await supabase
        .from('subcategories')
        .insert({
          category_id: categoryId,
          name: 'Test Subcategory ' + Date.now()
        })
        .select();
      
      if (insertError) {
        console.log(`‚ùå –û—à–∏–±–∫–∞ –≤—Å—Ç–∞–≤–∫–∏: ${insertError.message}`);
      } else {
        console.log(`‚úÖ –¢–µ—Å—Ç–æ–≤–∞—è –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è —Å–æ–∑–¥–∞–Ω–∞: ${insertResult?.length || 0}`);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ subs –æ–±–Ω–æ–≤–∏–ª—Å—è
        const { data: updatedCategory, error: updateError } = await supabase
          .from('categories')
          .select('id, name, subs')
          .eq('id', categoryId)
          .single();
        
        if (updateError) {
          console.log(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: ${updateError.message}`);
        } else {
          console.log(`‚úÖ –ö–∞—Ç–µ–≥–æ—Ä–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞: ${updatedCategory?.subs?.length || 0} subcategories`);
        }
      }
    }

  } catch (error) {
    console.error('‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:', error);
  }
}

fixSubcategoriesSync();
